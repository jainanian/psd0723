---
title: "230723 psd vignette"
output: html_document
date: "2023-07-23"
---

# load directory pdfs

## call data archives org api

```{r }
require(tidyverse)
library(piggyback)
require(httr)
require(openxlsx)
# loadWorkbook_url <- function(url) {
#     temp_file <- tempfile(fileext = ".xlsx")
#     download.file(url = url, destfile = temp_file, mode = "wb", quiet = TRUE)
#     unzip(temp_file)
#   d <- readxl::read_excel( temp_file)
#    # loadWorkbook(temp_file, isUnzipped = TRUE)
# #   d
# }

 
  
archives_df <- jsonlite::fromJSON(
  "https://archive.org/advancedsearch.php?q=Meat+inspection+United+States+Directories&fl%5B%5D=avg_rating&fl%5B%5D=backup_location&fl%5B%5D=btih&fl%5B%5D=call_number&fl%5B%5D=collection&fl%5B%5D=contributor&fl%5B%5D=coverage&fl%5B%5D=creator&fl%5B%5D=date&fl%5B%5D=description&fl%5B%5D=downloads&fl%5B%5D=external-identifier&fl%5B%5D=foldoutcount&fl%5B%5D=format&fl%5B%5D=genre&fl%5B%5D=identifier&fl%5B%5D=imagecount&fl%5B%5D=indexflag&fl%5B%5D=item_size&fl%5B%5D=language&fl%5B%5D=licenseurl&fl%5B%5D=mediatype&fl%5B%5D=members&fl%5B%5D=month&fl%5B%5D=name&fl%5B%5D=noindex&fl%5B%5D=num_reviews&fl%5B%5D=oai_updatedate&fl%5B%5D=publicdate&fl%5B%5D=publisher&fl%5B%5D=related-external-id&fl%5B%5D=reviewdate&fl%5B%5D=rights&fl%5B%5D=scanningcentre&fl%5B%5D=source&fl%5B%5D=stripped_tags&fl%5B%5D=subject&fl%5B%5D=title&fl%5B%5D=type&fl%5B%5D=volume&fl%5B%5D=week&fl%5B%5D=year&sort%5B%5D=&sort%5B%5D=&sort%5B%5D=&rows=50&page=1&output=json"
)
archives_df_2 <- archives_df$response$docs %>% 
  mutate(
    url = paste0("https://archive.org/stream/", identifier,"/", identifier, "_djvu.txt"), 
    pdf_url  = paste0("https://archive.org/8/items/", identifier,"/", identifier, ".pdf")
  )

archives_df_2 %>% writexl::write_xlsx(
   "230630_archivesorg_table_out.xlsx"
)

```

```{r }
archives_df <- readxl::read_excel(
  "230630_archivesorg_table.xlsx"
)
 ## https://rogerdudler.github.io/git-guide/
 
```

```{r }
stringi_str_order <- function(y) {
  require(stringi)

  vapply(stri_split_boundaries(toupper(y), type = "character"), function(x) stri_c(x[stri_order(x)], collapse = ""), "")
}


```

```{r }
fsis_init_LU <- readxl::read_excel(
  "230630_fsis_initialLU.xlsx"
)

fsis_init_LU_combo <- crossing(
  combination = unlist(lapply(1:nrow(fsis_init_LU), function(n) combn(fsis_init_LU$Initial, n, paste, collapse=""))), 
  ending = c(",", ".")
) %>% 
  mutate(
    combination =  stringi_str_order( combination),
    finalpattern = paste0(
      # (gsub("\\.", ".",
      ending,
      # ), 
      # (gsub( 
   combination #, 
      # "$"
    )
    
  )
# fsis_init_LU_combo_pattern <- fsis_init_LU_combo
# %>% 
#   mutate(
#     
#   )
  
```

## function to split pdfs
```{R }

func_to_split_by_init <- function(funcsplit_df,  funcsplit_pattern )
{
require(data.table)
require(tm)
require(splitstackshape)
  require(tidycensus)
  
  data(fips_code)
funcsplit_pattern <- fsis_init_LU_combo

# fsis_init_LU_combo_patterns <- funcsplit_pattern %>% 
#   summarise(
#     patternfinal = paste(
#       finalpattern %>% unique(), collapse = "|"
#     )
#   ) %>% 
#   ungroup()

# funcfind_pattern <- function(y){
#   
#   
# }

# this func reads the url text
funcsplit_readdoc <- function(x){
    require(splitstackshape)
  require(stringi)
arch_2000_dec <- readr::read_tsv("https://archive.org/stream/CAT10193534071/CAT10193534071_djvu.txt", col_names = c("text")) %>% 
  mutate(
    rownum= row_number()
  )
  

}
# this func takes a df, splits a colname (splitcol = provided name of column, eg text1, and reformats the text into )
# the occurrence of ids is 1. decimal, typesplit letters; followed by 2. decimal , meat or poultry (M or P)
funcsplit_splitinto <- function(splintinto_df , splitinto_colname = "text1", splintinto_char = "/", 
    splitinto_outputchar = "/"){
  # arch_2000_dec_text_begin_idLU_onlynum
  # splintinto_df <- arch_2000_dec_positions %>% 
  #   filter(
  #     (rownum <= 7728), 
  #     rownum >= 7720
  #   )
#   splintinto_df <- arch_2000_dec_text_begin_idLU_onlynum 
# 
# splitinto_colname = "text"
# splintinto_char = "/"
# splitinto_outputchar = "/"
# rm(splitinto_dfLU)
# rm(splitinto_outputchar)
# rm(splintinto_char)
# rm(splitinto_colname)
# rm(splintinto_df)

  splitinto_dfLU <- splintinto_df %>% 
    cSplit(., splitCols =splitinto_colname, splintinto_char, drop = FALSE) %>% 
  mutate(
    rownum2 = row_number(), 
    id = text1,
    type = text2
    ) %>% 
  gather(
    key = textno, 
    value = value, 
     contains( paste0( splitinto_colname, "_"))
  ) %>% 
  mutate(
    textno_num = as.numeric(
        gsub(
        "[^[:digit:]]", "",  value , perl = TRUE
      )
      ), 
    textno_letter = (
        gsub(
        "[^[:alpha:]]", "",  value , perl = TRUE
      )
      )

  ) %>% 
      filter(
     !is.na(textno_num )
  )%>% 
    mutate(
      texno_letterM = 
        case_when( 
          grepl("M",textno_letter, perl = TRUE, ignore.case =TRUE )  ~ 1, 
          TRUE ~ 0
    ),
    texno_letterPstart = 
        case_when( 
          grepl("^P",textno_letter, perl = TRUE, ignore.case =TRUE )  ~ 1, 
          TRUE ~ 0
    ) 

    ) %>% 
    group_by(
      rownum
    ) %>% 
    mutate(
      texno_letterM_sum = sum(texno_letterM, na.rm = TRUE), 
      rownum_rownum = row_number()
    ) %>% 
    ungroup() %>% 
    mutate(
      textno_num_convert_I_1 =  
        gsub(
          "[^[:digit:]]", 
          "",
          gsub(
          "O", "I",
          gsub(
          "I", "1",value
          ) , perl = TRUE
        )
        )%>% as.numeric() ,
      textno_letter_concM = 
        case_when(
          # when current obs is not m and there is no other m, prefix M
          (texno_letterM!=1)&(!(texno_letterM_sum>=1 ))&(texno_letterPstart!=1) ~ paste0(textno_letter, "M"),           
          # when it is M or contains M, let it be the same; just put M at end
          (texno_letterM==1)&((texno_letterM_sum>=1 )) ~ 
            paste0(
              gsub(
                "M", "", textno_letter 
              ), "M"
              )
              , 
          # when it is p or contains p,put p at end
          TRUE ~ paste0(
              gsub(
                "P", "", textno_letter 
              ), "P"
              )
        ), 
      textno_letter_concat = paste0(
        textno_letter_concM,"-", textno_num
      ), 
      # place idsub containing M at beginning, id1, of id1/id2  pairing
      texno_letterM_new = 
        case_when( 
          grepl("M",textno_letter_concat, perl = TRUE, ignore.case =TRUE )  ~ 0, 
          TRUE ~ 1 
    )
    )%>%  
    # arrange(
    #   rownum
    # )
    # filter(
    #   (nchar( textno_letter)>=1)
    # ) %>% 
  group_by(
   text,  rownum
  ) %>% 
    arrange(texno_letterM_new) %>% 
    # arrange(
    #   textno_letter_concat
    # ) 
  summarise(
    id_no = paste(
      textno_letter_concat, collapse =splitinto_outputchar
    ), 
    id_onlydecimal =  paste(
      textno_num %>% sort(), collapse =splitinto_outputchar
    ), 
    id_onlydecimal_convert_I_1 = paste(
      textno_num_convert_I_1 %>% sort(), collapse =splitinto_outputchar
    )
  ) %>% 
  ungroup()   %>% 
      arrange(
      rownum
    )

  splintinto_df %>% 
    left_join(
      splitinto_dfLU %>% 
        rename(id_origtext = text ), 
      by = c("rownum" )
    )
  
  
} 

# this takes text and separates this into two columns based on . or , ; eg .PB 
arch_2000_dec_text  <- arch_2000_dec%>%
  separate(text, into = c('text1', 'text2'), sep = "\\.|,", fill = "right", remove = FALSE) %>% 
  mutate(
    text2 = gsub(" ", "", text2, perl = TRUE),
    text2_keeporder = text2,
    text2 = stringi_str_order( text2)
  )

# this then filters down to only those where text2 delim column matches those in the pattern (Eg .pb, .s, etc); 
# the last filter step makes sure that the pattern terminates text2
arch_2000_dec_positions<- arch_2000_dec_text %>% 
  # mutate(
  #   GEOID = purrr::map(files,
  #                      ~readxl::read_excel(.x ))
  # ) %>% 
  filter(
       # rownum == 7643,
   text2 %in% c(funcsplit_pattern$combination), 
   nchar(text1)>=2 #, 
   # rownum >= 7720
  ) %>% 
  mutate(
    rownum2 = row_number(),
    rownum2_end = paste0(text2_keeporder, "$")
  ) %>% 
  group_by(
    rownum2
  ) %>% 
  filter(
    grepl(rownum2_end, text)
  ) %>% 
  ungroup() 



# 
# arch_2000_dec_positions_idsplit <- arch_2000_dec_positions_idsplitLU %>% 
#   mutate(
#     rownum2 = row_number(), 
#     id = text1,
#     type = text2
#     )# %>% 

# 
# arch_2000_dec_positions_idsplit <- #arch_2000_dec_positions %>% 
#   #mutate(
#        cSplit(arch_2000_dec_positions, splitCols ="text1", "/", drop = FALSE) %>% 
#   mutate(
#     rownum2 = row_number(), 
#     id = text1,
#     type = text2
#     )# %>% 
 # ) %>% 
  # select(
  #   text:rownum
  # )
 # arch_2000_dec_positions_idsplitLU <- #arch_2000_dec_positions %>% 
 #  #mutate(
 #       cSplit(arch_2000_dec_text, splitCols ="text", "/", drop = FALSE) %>% 
 #  gather(
 #    key = textno, 
 #    value = value, 
 #     contains("text_")
 #  ) %>% 
 #  mutate(
 #    textno_num = as.numeric(
 #        gsub(
 #        "[^[:digit:]]", "",  value , perl = TRUE
 #      )
 #      )
 #  ) %>% 
 #  filter(
 #     !is.na(textno_num )
 #  )%>% 
 #  group_by(
 #   text,  rownum
 #  ) %>% 
 #  summarise(
 #    id_no = paste(
 #      textno_num, collapse = "/"
 #    )
 #  ) %>% 
 #  ungroup() 
 # 

 
 # this uses  the function that takes what we belive is the id column; and returns a standardized id format eg M-342/P-234 (ie id_no)

 arch_2000_dec_positions_idsplitLU <- arch_2000_dec_positions%>% 
   # filter()
  funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "text1", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    )
   
 # takes the text filters to start; joins to actutal id (id) 
 # and fills down
 # first top id
arch_2000_dec_text_begin <- arch_2000_dec_text %>% 
  filter(
    rownum >= (arch_2000_dec_positions$rownum %>% min())
  ) %>% 
 left_join(
    arch_2000_dec_positions_idsplitLU %>% 
      rename(
        id = id_no, 
        type = text2, 
        id_numberonly = id_onlydecimal, 
        id_origtext_id1 = id_origtext, 
        id_numberonly_convertI_1 = id_onlydecimal_convert_I_1
      )  %>% 
      select(rownum, id, id_origtext_id1, type, id_numberonly, id_numberonly_convertI_1)  %>% 
      # mutate(
      #   rownum2 = row_number()
      # )
      distinct(), 
    by = c("rownum")
  ) %>% 
  # mutate(
  #   type = 
  # )
  fill(
    id, .direction = "down"
  )%>% 
    fill(
    id_numberonly, .direction = "down"
  )%>% 

  fill(
     id_numberonly_convertI_1, .direction = "down"
  )%>%
    fill(
     id_origtext_id1, .direction = "down"
  )%>% 

  fill(
     type, .direction = "down"
  )%>% 
  #why is below needed
  mutate(
    firstchar_textcol = substr(text, 1, 1)
    )

### this step produces one column with only numbers of ; meant to be a substitute for 
arch_2000_dec_text_begin_idLU_onlynum <- arch_2000_dec_text_begin %>% 
  # filter(
  #   !rownum %in% c( arch_2000_dec_positions_idsplitLU$rownum),
  #   rownum >=9218
  # ) %>%
  mutate(
    textoriginal_onlynum = text
  ) %>% 
  select(
  any_of(c(arch_2000_dec_text_begin %>% names(), "textoriginal_onlynum") )  
  ) %>% 
    funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "textoriginal_onlynum", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    )  %>% 
  select(
  rownum, id_onlydecimal , id_onlydecimal_convert_I_1, id_no
  ) %>% 
  distinct() %>% 
      rename(
        # id_bottom = id_no, 
        # id_bottomorigtext = id_origtext ,
        text_onlydecimal = id_onlydecimal  , 
        text_onlydecimal_convert_I_1 = id_onlydecimal_convert_I_1, 
        text_idno = id_no
      )


# this next step will produce the bottom ids if present
arch_2000_dec_text_begin_id2LU <- arch_2000_dec_text_begin %>% 
  filter(
    !rownum %in% c( arch_2000_dec_positions_idsplitLU$rownum) 
  ) %>% 
  select(
  any_of(c(arch_2000_dec_text_begin %>% names()) )  
  ) %>% 
    funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "text1", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    ) 

# do this in two parts: ones where 

### join
arch_2000_dec_text_begin_id2LU_LU <- arch_2000_dec_text_begin %>% 
  left_join(
    arch_2000_dec_text_begin_id2LU %>% 
      rename(
        id_bottom = id_no, 
        id_bottomorigtext = id_origtext ,
        id_bottom_onlydecimal = id_onlydecimal, 
        id_bottom_onlydecimal_convert_I_1 = id_onlydecimal_convert_I_1
      )  %>% 
    
      select(rownum, id_bottom, id_bottomorigtext, id_bottom_onlydecimal, id_bottom_onlydecimal_convert_I_1)  %>% 
      # mutate(
      #   rownum2 = row_number()
      # )
      distinct(), 
    by = c("rownum")
  ) %>% 
  left_join(
    arch_2000_dec_text_begin_idLU_onlynum, 
    by = c("rownum")
  )

##### 1  exact match
arch_2000_dec_text_begin_id2LU_LU_bottomtop <- arch_2000_dec_text_begin_id2LU_LU %>% 

  filter(
    # this allows the standardized id match; or numeric id match in same row
    (id_bottom == id)
    ) %>% 
  mutate(
    matchtype = "bottom_top_exactmatch"
  )
##### 2 number only for top == bottom
arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly <- arch_2000_dec_text_begin_id2LU_LU %>% 

  filter(
    # this allows the standardized id match; or numeric id match in same row!rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
    (id_numberonly==id_bottom_onlydecimal)
    ) %>% 
  mutate(
    matchtype = "bottom_top_numbermatch"
  )

# 3 number only for top == bottom; convert I -> 1; O -> 0
arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly_I_1 <- arch_2000_dec_text_begin_id2LU_LU %>% 

  filter(
    # this allows the standardized id match; or numeric id match in same row!rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly$rownum),
    (id_numberonly_convertI_1== id_bottom_onlydecimal_convert_I_1)
    )%>% 
  mutate(
    matchtype = "bottom_top_numbermatch"
  )

# 4   Unsure top and bottom  - just convert to id matches
## need to filter out bottoms? and tops?
# number only for top == bottom
arch_2000_dec_text_begin_id2LU_LU_other_idonly <- arch_2000_dec_text_begin_id2LU_LU %>% 
  filter(
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
    !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly$rownum),
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly_I_1$rownum),
   
   id ==text_idno
  )


# number only for top == bottom
arch_2000_dec_text_begin_id2LU_LU_other_idonly <- arch_2000_dec_text_begin_id2LU_LU %>% 
  filter(
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop$rownum),
    !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly$rownum),
     !rownum %in% c(arch_2000_dec_text_begin_id2LU_LU_bottomtop_numberonly_I_1$rownum),
   
  (text_onlydecimal ==id_bottom_onlydecimal )|(text_onlydecimal == id_bottom_onlydecimal_convert_I_1 )
  )

 arch_2000_dec_text_begin_id <- arch_2000_dec_text_begin %>% 
   left_join(
     arch_2000_dec_text_begin_id2LU_LU %>% 
       select(
        rownum, id_bottom, id_bottomorigtext, id_bottom_onlydecimal, id_bottom_onlydecimal_convert_I_1,text_onlydecimal
       ) %>% 
       distinct(),
     by= c("rownum")
   ) %>% 
   group_by(
     id
   ) %>% 
  #   fill(
  #    id_bottomorigtext, .direction = "down"
  # )%>% 
    fill(
     id_bottom, .direction = "up"
  )%>% 
    fill(
     id_bottomorigtext, .direction = "up"
  ) %>% 
  fill(
     id_bottom_onlydecimal, .direction = "up"
  )%>% 
  fill(
     id_bottom_onlydecimal_convert_I_1, .direction = "up"
  )%>% 

   ungroup()
 # ones that don't have accompanying bottom
 # 7238 rownum 
# 12PA/P834 row7298 (both 7298 and 7238 should include an M in first P if there are two Ps)
 # 7465 # BM-21/P-748 21B/P748,PY; end is 0002 IB  M/00748  P (bc i gets coded as 1)
 # at end of day, just want 
 
 ### 7/23;
 # # problem with row 7720	
# 850/P17775.SPBEIY 
 
 ## problem with 9218; doesn't have .PB, so doesn't get labelled as ID first go around. Solve by simply making 
 arch_2000_dec_text_begin_id %>% 
   filter(
     is.na(( id_bottomorigtext))
   ) %>% 
   View()
# 
#    arch_2000_dec_text_begin%>% 
#     filter(
#         id == "00226  M/04863"
#     ) %>% View()

 # this begins to take 
arch_2000_dec_text_begin_firmLU <- arch_2000_dec_text_begin_id %>% 
  filter(
    firstchar_textcol != "("
  ) %>% 
  group_by(
    id
  ) %>% 
  # mutate(
  #   notes = p
  # )
  mutate(
    id_rownum = row_number()
  ) %>% 
  ungroup() %>% 
  mutate(
    firstchar_textcol2= substr(text, 1, 1),
    firm  = case_when(
      (
        (id_rownum ==2) #
        & firstcharfirm != "("
        )~ gsub(
         "&amp;", "", 
          text  
        )
    ), 
    rownum_firmLU = 
      case_when(
        !is.na(firm) ~ rownum
      )
) %>% 
  group_by(
    id, rownum2
  )  %>% 
  fill(
    firm,  .direction = "downup"
  )%>% 
  fill(
    rownum_firmLU,  .direction = "downup"
  ) %>% 
  ungroup() %>% 
  select(
    id, rownum2, firm, rownum_firmLU
    ) %>% 
  distinct() %>% 
  #needed to fill in NA in case 
  fill(
    firm, .direction = "down"
  )%>% 
  fill(
    rownum_firmLU,  .direction = "down"
  ) 

arch_2000_dec_text_begin_firm <- arch_2000_dec_text_begin %>% 
  left_join(
    arch_2000_dec_text_begin_firmLU, 
    by = c("id", "rownum2")
  ) 

arch_2000_dec_text_begin_otherprocess <- arch_2000_dec_text_begin_firm %>% 
  filter(
    firstcharfirm  == "(" 
  ) %>% 
  mutate(
    ifmail = substr(text, 1,6) 
  ) %>% 
  filter(
    !grepl( "(MAIL)" , ifmail, ignore.case = TRUE, perl = TRUE), 
    grepl("INSPECTION",text , ignore.case = TRUE, perl = TRUE)
  ) %>% 
  mutate(
    type_specialinspect = (gsub(
       "[^[:alpha:]]|INSPECTION", "", str_squish(text)
      )
  )
  )%>% 
  group_by(
    id, rownum2
  ) %>% 
  summarise(
    type_specialinspect =  paste(type_specialinspect %>% unique() %>% sort(), collapse = ", ")
  ) %>% 
  ungroup()
#%>% 
  # mutate(
  #   firm = case_when(
  #     (is.na(firm) & (id_rownum ==3) & firstcharfirm != "(" )~ text,
  #     TRUE ~ firm
  #   ),
  #     
  #     firm = gsub(
  #       "  ", " ", 
  #       gsub(
  #      "&amp;", "&",  firm
  #     )
  #     
  #     )
  #    
  #   
  # )%>% 
  # group_by(
  #   id, rownum2
  # )  %>% 
  # fill(
  #   firm,  .direction = "downup"
  # )%>% 
  # ungroup()

arch_2000_dec_text_begin_stateLU <-  arch_2000_dec_text_begin_firm %>% 
  filter(
    nchar( text2) >=2
  ) %>% 
  mutate(
    poss_state = 
      gsub(
       "[^[:alpha:]]", "", str_squish(text2)
      )
      # sub(".*\\b([A-Z]{2}).*", "\\1", str_squish(text2))
  ) %>% 
  filter(
    poss_state %in% c(fips_codes$state)
  ) %>% 
  group_by(
    id, rownum2, firm
  ) %>% 
  mutate(
    rownum_state = row_number() 
  ) %>% 
  ungroup() %>%  
  filter(
    (rownum_state == 1 )| ( rownum_state == 2 & rownum2 == max(rownum2))
  )

arch_2000_dec_text_begin_state <- arch_2000_dec_text_begin_firm %>% 
  filter(
    rownum < (arch_2000_dec_text_begin_stateLU$rownum %>% max()) 
  ) %>% 
  left_join(
    arch_2000_dec_text_begin_stateLU %>% 
      filter(rownum_state == 1  ) %>%
      mutate(rownum_stateLU  = rownum) %>% 
      select(poss_state, rownum2, id, rownum_stateLU), 
    by = c("rownum2", "id")
  ) %>% 
  left_join(
     arch_2000_dec_text_begin_otherprocess %>% 
      # mutate(
      #   rownum_otherprocessLU  = rownum
      #   ) %>% 
      select(type_specialinspect , rownum2, id), 
    by = c("rownum2", "id")
  )
arch_2000_dec_text_begin_addressLU <- arch_2000_dec_text_begin_state  %>% 
  filter(
    rownum ==  (rownum_stateLU -1)
    # (rownum <=  (rownum_stateLU-1)) & (rownum >rownum_firmLU) 
  )
   
arch_2000_dec_text_begin_address <- arch_2000_dec_text_begin_state %>% 
  left_join(
    arch_2000_dec_text_begin_addressLU %>% 
      mutate(
        street = text
      ) %>% 
      select(
        street, rownum2, id
      ), 
    by = c("rownum2", "id")
  ) %>% 
  rename(
  state   = poss_state 
  ) %>% 
  group_by(
    rownum2, id
  ) %>% 
  mutate(
    rownum2_rownumwithin = row_number()
  ) %>% 
  ungroup()

arch_2000_dec_text_begin_idLU <-
  # split these into all ids, then gather
         cSplit(arch_2000_dec_text_begin_address, splitCols ="text1", "/", drop = FALSE) %>% 
  select(
    text1,id, rownum2, contains("text1_")
  ) %>% 
  cbind(
    cSplit(arch_2000_dec_text_begin_address, splitCols ="id", "/", drop = FALSE) %>% 
  select(
    contains("id_")
  )
  ) %>% 
  gather(
    key = textno, 
    value = value, 
     contains("text1_"), contains("id_")
  )  

  arch_2000_dec_text_begin_idLU2 <-  arch_2000_dec_text_begin_idLU %>% 
    mutate(
      id_letter =  gsub(
       "[^[:alpha:]]", "",  value 
      ),
      id_number = as.numeric(
        gsub(
        "[^[:digit:]]", "",  value 
      )
      )
    ) %>% 
    filter(
    nchar(id_number) >=1
    ) 
  
arch_2000_dec_text_begin_idLU3 <-arch_2000_dec_text_begin_idLU2  %>% 
    mutate(
      id_letter_M =
        case_when(
         (  text1== id) & !(nchar(id_letter)>=1) ~ "M",
         ((  text1== id)&  grepl("text1_", textno, perl = TRUE))  ~ paste0( id_letter,"M"),
         (!(nchar(id_letter)>=1) &  grepl("id_", textno, perl = TRUE)) ~ "M",

          TRUE ~ id_letter
        ) ,
      id_concat_m = paste0(id_letter_M,id_number )
    ) %>% 
  distinct() %>% 
  group_by(
    id,textno, id_concat_m, rownum2
  ) %>% 
  mutate(
    num_id_m_occur = n(), 
    num_id_m_occur_rowid = row_number()
  ) %>% 
  ungroup()
arch_2000_dec_text_begin_idLU3 %>% 
  filter(
    id == "00226  M/04863"
  ) %>% View()

"00226  M/04863"
# this should pull all top ids and trailing ids 
arch_2000_dec_text_begin_idLU4 <-arch_2000_dec_text_begin_idLU3%>% 
  filter(
     grepl("text1_", textno, perl = TRUE), 
     # ==2 should be trailing OR id = text1 captures top id
    ( num_id_m_occur ==2 )| ( id == text1) 
  ) %>% 
  group_by(
    id
  ) %>% 
  summarise(
    id_concat_m = paste( id_concat_m %>% unique() %>% sort(), collapse = "+")
  ) %>% 
  ungroup()
  
  left_join(
    arch_2000_dec_text_begin_idLU3%>% 
  filter(
     grepl("id_", textno, perl = TRUE)
  )
  )
  
#needs to be a bind !id in above

arch_2000_dec_text_begin_idLU3 %>% 
  filter(
    grepl("text1", textno, perl = TRUE)
  )   %>% 
  group_by(
    num_id_m_occur
  ) %>% 
  summarise(
    count = length(unique(id))
  ) %>% 
  arrange(-count) %>% 
  View()
    
arch_2000_dec_text_begin_idLU4 <- arch_2000_dec_text_begin_idLU3%>% 
  select(
 id,textno, id_concat_m, rownum2
  ) %>% 
  distinct() %>% 
  mutate(
    idtype = gsub("_.*","", textno, perl = TRUE )
  ) %>% 
  group_by(
    id,id_concat_m, rownum2
  )

  mutate(
    id_possible_number = 
      # paste(
      stringr::str_extract_all(value, "M|P|\\d+"), 
        id_top_possible_number = 
      # paste(
      stringr::str_extract_all(id, "M|P|\\d+")#, 

    # if_backslash = 
    #   gsub(
    #     "[^\\/]", "", text1
    #   )
      #   collapse = "/"
      # )#,
      
      # gsub("([0-9]+).*$", "\\1", text) 
  ) %>% 
  # filter(
  #   id_possible_number != "character(0)"
  # ) %>%
  unnest(
    cols = c("id_possible_number")
  ) %>%
  unnest(
    cols = c("id_top_possible_number")
  ) %>% 
 group_by(rownum, firm, text,rownum2) %>% 
  summarise(
    id_possible_number = paste(id_possible_number %>% unique() %>%as.numeric() %>%  sort() , collapse = "/" ),
    id_top_possible_number = paste(id_top_possible_number %>% unique() %>%as.numeric() %>%  sort() , collapse = "/" )
  ) %>% 
  ungroup() %>%  
  filter(
    id_possible_number ==id_top_possible_number
  )
 transmute(
   id_possible_number  = str_c(c_across("id_possible_number"), collapse = "/"),
   id_top_possible_number = str_c(c_across("id_top_possible_number"), collapse = "/") 
   
   
   )
  group_by(
    rownum2, id
  ) %>% 
  filter(
    rownum2_rownumwithin == max( rownum2_rownumwithin)
  ) %>% 
  ungroup()
arch_2000_dec_text_begin_dbaLU <- arch_2000_dec_text_begin_address %>% 
  filter(
    rownum < (arch_2000_dec_text_begin_stateLU$rownum %>% max()) 
  ) %>% 
  left_join(
    
  )

  summarise(
    
  )
  # fill()
  mutate(
    rownum2 = fill( )
  )
    

}
 
  
```

# git code 
```{r }
# https://rogerdudler.github.io/git-guide/
# https://rfortherestofus.com/2021/02/how-to-use-git-github-with-r/
# git add *
# git commit -m "committed 230723"
# git push origin 

```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
