---
title: "230723 psd vignette"
output: html_document
date: "2023-07-23"
---

# load directory pdfs

## call data archives org api

```{r }
require(tidyverse)
library(piggyback)
require(httr)
require(openxlsx)
# loadWorkbook_url <- function(url) {
#     temp_file <- tempfile(fileext = ".xlsx")
#     download.file(url = url, destfile = temp_file, mode = "wb", quiet = TRUE)
#     unzip(temp_file)
#   d <- readxl::read_excel( temp_file)
#    # loadWorkbook(temp_file, isUnzipped = TRUE)
# #   d
# }

 
  
archives_df <- jsonlite::fromJSON(
  "https://archive.org/advancedsearch.php?q=Meat+inspection+United+States+Directories&fl%5B%5D=avg_rating&fl%5B%5D=backup_location&fl%5B%5D=btih&fl%5B%5D=call_number&fl%5B%5D=collection&fl%5B%5D=contributor&fl%5B%5D=coverage&fl%5B%5D=creator&fl%5B%5D=date&fl%5B%5D=description&fl%5B%5D=downloads&fl%5B%5D=external-identifier&fl%5B%5D=foldoutcount&fl%5B%5D=format&fl%5B%5D=genre&fl%5B%5D=identifier&fl%5B%5D=imagecount&fl%5B%5D=indexflag&fl%5B%5D=item_size&fl%5B%5D=language&fl%5B%5D=licenseurl&fl%5B%5D=mediatype&fl%5B%5D=members&fl%5B%5D=month&fl%5B%5D=name&fl%5B%5D=noindex&fl%5B%5D=num_reviews&fl%5B%5D=oai_updatedate&fl%5B%5D=publicdate&fl%5B%5D=publisher&fl%5B%5D=related-external-id&fl%5B%5D=reviewdate&fl%5B%5D=rights&fl%5B%5D=scanningcentre&fl%5B%5D=source&fl%5B%5D=stripped_tags&fl%5B%5D=subject&fl%5B%5D=title&fl%5B%5D=type&fl%5B%5D=volume&fl%5B%5D=week&fl%5B%5D=year&sort%5B%5D=&sort%5B%5D=&sort%5B%5D=&rows=50&page=1&output=json"
)
archives_df_2 <- archives_df$response$docs %>% 
  mutate(
    url = paste0("https://archive.org/stream/", identifier,"/", identifier, "_djvu.txt"), 
    pdf_url  = paste0("https://archive.org/8/items/", identifier,"/", identifier, ".pdf")
  )

archives_df_2 %>% writexl::write_xlsx(
   "230630_archivesorg_table_out.xlsx"
)

```

```{r }
archives_df <- readxl::read_excel(
  "230630_archivesorg_table.xlsx"
)
 ## https://rogerdudler.github.io/git-guide/
 
```

```{r }
stringi_str_order <- function(y) {
  require(stringi)

  vapply(stri_split_boundaries(toupper(y), type = "character"), function(x) stri_c(x[stri_order(x)], collapse = ""), "")
}


```

```{r }

save.image("journal/230723_save image.RData")
```

```{r }
fsis_init_LU <- readxl::read_excel(
  "230630_fsis_initialLU.xlsx"
) %>% 
  bind_rows(
    tibble(
      Initial = "1", 
      Long = "Inspection"
    )
  )%>% 
  bind_rows(
    tibble(
      Initial = "!", 
      Long = "Inspection"
    )
  )

fsis_init_LU_combo <- crossing(
  combination = unlist(lapply(1:nrow(fsis_init_LU), function(n) combn(fsis_init_LU$Initial, n, paste, collapse=""))), 
  ending = c(",", ".")
) %>% 
  mutate(
    combination =  stringi_str_order( combination),
    finalpattern = paste0(
      # (gsub("\\.", ".",
      ending,
      # ), 
      # (gsub( 
   combination #, 
      # "$"
    )
    
  )
# fsis_init_LU_combo_pattern <- fsis_init_LU_combo
# %>% 
#   mutate(
#     
#   )
  
```

## aux functions

### function  reads the url text
```{r }
# this func reads the url text
funcsplit_readdoc <- function(x){
    require(splitstackshape)
  require(stringi)
dftext <- readr::read_tsv("https://archive.org/stream/CAT10193534071/CAT10193534071_djvu.txt", col_names = c("text")) %>% 
  mutate(
    rownum= row_number()
  ) 
  

}


```

### function filter for pattern
```{r }

### basically this will try to find the instances of TEXT THAT CONTAINS patterns xfilterchar; and will filter for those in which the number <= numtofilter of extra distinct characters besides the patterns that 
funcsplit_function_filter_forpattern <- function(x, x_filterchar, x_num_tofilter = 3){
# 
 x <- dftext_sep_not_prefix
 x_filterchar = splitinto_pattern_MPbottom
   x_num_tofilter = 3
x_out <- x%>% 
  group_by(
    rownum
  ) %>%
  mutate(
    text1_bottom = 
      paste(
        str_extract_all(
        pattern = x_filterchar , 
        text1_nospace
      ) %>% unlist(), 
      collapse = "|"
      )
    )%>%
  ungroup()  

x_out2 <- x_out%>% 
  filter(
    nchar(text1_bottom ) >=2,
    !is.na(text1_bottom ), text1_bottom != "NA"
  ) %>% 
  mutate(
    text1_bottom_filter =
      str_remove_all(
        string = text1_nospace, 
        pattern = text1_bottom
      ), 
 text1_bottom_countdistinct = 
          nchar(char_unique(text1_bottom_filter)) , 
 text2_countdistinct = nchar(text2) 

)%>% 
  filter(
    text1_bottom_countdistinct <= x_num_tofilter, 
    ((text2_countdistinct <= funcsplit_pattern_maxnum)|
      is.na( text2))
  )
x_out  %>%
    filter(
        grepl("04247", text, perl = TRUE)
    ) %>%
  View()

x_out2  %>%
    filter(
        grepl("04247", text, perl = TRUE)
    ) %>%
  View()
x_out2
}

```

### function - char unique
```{r }
require(splitstackshape)
require(inline)
char_unique <- 
  rcpp(sig=signature(x="std::vector < std::string >"),
       body=.char_unique_code,
       includes=c("#include <string>",
                 "#include <iostream>"))


```

### function funcsplit_splitinto

```{r }
# this func takes a df, splits a colname (splitcol = provided name of column, eg text1, and reformats the text into )
# the occurrence of ids is 1. decimal, typesplit letters; followed by 2. decimal , meat or poultry (M or P)
funcsplit_splitinto <- function(splintinto_df , splitinto_colname = "text1", splintinto_char = "/", 
    splitinto_outputchar = "/"){
  # dftext_septext_notid1row
  # splintinto_df <- dftext_onlyID1row %>% 
  #   filter(
  #     (rownum <= 7728), 
  #     rownum >= 7720
  #   )
#   splintinto_df <- dftext_septext_notid1row 
# 
# splitinto_colname = "text"
# splintinto_char = "/"
# splitinto_outputchar = "/"
# rm(splitinto_dfLU)
# rm(splitinto_outputchar)
# rm(splintinto_char)
# rm(splitinto_colname)
# rm(splintinto_df)
  
  
  

      
      
      require(inline)

.char_unique_code <- "
std::vector < std::string > s = as< std::vector < std::string > >(x);
unsigned int input_size = s.size();

std::vector < std::string > chrs(input_size);

for (unsigned int i=0; i<input_size; i++) {

  std::string t = s[i];

  for (std::string::iterator chr=t.begin();
       chr != t.end(); ++chr) {

    if (chrs[i].find(*chr) == std::string::npos) {
      chrs[i] += *chr;
    }

  }

}
return(wrap(chrs));
"

      
  splitinto_dfLU <- splintinto_df %>% 
    cSplit(., splitCols =splitinto_colname, splintinto_char, drop = FALSE) %>% 
  mutate(
    rownum2 = row_number(), 
    id = text1,
    type = text2
    ) %>% 
  gather(
    key = textno, 
    value = value, 
     contains( paste0( splitinto_colname, "_"))
  ) %>% 
  mutate(
    textno_num = as.numeric(
        gsub(
        "[^[:digit:]]", "",  value , perl = TRUE
      )
      ), 
    textno_letter = (
        gsub(
        "[^[:alpha:]]", "",  value , perl = TRUE
      )
      )

  ) %>% 
      filter(
     !is.na(textno_num )
  )%>% 
    mutate(
      texno_letterM = 
        case_when( 
          grepl("M",textno_letter, perl = TRUE, ignore.case =TRUE )  ~ 1, 
          TRUE ~ 0
    ),
    texno_letterPstart = 
        case_when( 
          grepl("^P",textno_letter, perl = TRUE, ignore.case =TRUE )  ~ 1, 
          TRUE ~ 0
    ) 

    ) %>% 
    group_by(
      rownum
    ) %>% 
    mutate(
      texno_letterM_sum = sum(texno_letterM, na.rm = TRUE), 
      rownum_rownum = row_number()
    ) %>% 
    ungroup() %>% 
    mutate(
      textno_num_convert_I_1 =  
        gsub(
          "[^[:digit:]]", 
          "",
          gsub(
          "S", "5",
          gsub(
          "!", "1",
          gsub(
          "O", "0",
          gsub(
          "I", "1",value
          ) , perl = TRUE
        )
        )
          )
        )%>% as.numeric() ,
      textno_letter_concM = 
        case_when(
          # when current obs is not m and there is no other m, prefix M
          (texno_letterM!=1)&(!(texno_letterM_sum>=1 ))&(texno_letterPstart!=1) ~ paste0(textno_letter, "M"),           
          # when it is M or contains M, let it be the same; just put M at end
          (texno_letterM==1)&((texno_letterM_sum>=1 )) ~ 
            paste0(
              gsub(
                "M", "", textno_letter 
              ), "M"
              )
              , 
          # when it is p or contains p,put p at end
          TRUE ~ paste0(
              gsub(
                "P", "", textno_letter 
              ), "P"
              )
        ), 
      textno_letter_concat = paste0(
        textno_letter_concM,"-", textno_num
      ), 
      # place idsub containing M at beginning, id1, of id1/id2  pairing
      texno_letterM_new = 
        case_when( 
          grepl("M",textno_letter_concat, perl = TRUE, ignore.case =TRUE )  ~ 0, 
          TRUE ~ 1 
    )
    )%>%  
    # arrange(
    #   rownum
    # )
    # filter(
    #   (nchar( textno_letter)>=1)
    # ) %>% 
  group_by(
   text,  rownum
  ) %>% 
    arrange(texno_letterM_new) %>% 
    # arrange(
    #   textno_letter_concat
    # ) 
  summarise(
    id_no = paste(
      textno_letter_concat, collapse =splitinto_outputchar
    ), 
    id_onlydecimal =  paste(
      textno_num %>% sort(), collapse =splitinto_outputchar
    ), 
    id_onlydecimal_convert_I_1 = paste(
      textno_num_convert_I_1 %>% sort(), collapse =splitinto_outputchar
    )
  ) %>% 
  ungroup()   %>% 
      arrange(
      rownum
    )

  splintinto_df %>% 
    left_join(
      splitinto_dfLU %>% 
        rename(id_origtext = text ), 
      by = c("rownum" )
    )
  
  
} 


```

## actual function to split pdfs
```{R }

func_to_split_by_init <- function(funcsplit_df,  funcsplit_pattern )
{
require(data.table)
require(tm)
require(splitstackshape)
  require(tidycensus)
 library(inline)
  
  
  
  
  data(fips_code)
  
  ### first M+ (M203), 
  
    splitinto_pattern_MP <- "M[[:digit:]]+|[[:digit:]]+M|P[[:digit:]]+|[[:digit:]]+P"
   ### first digit alpha / P digit,  eg 3CB/P6139.PB 
    ### second digit followed by P digit , eg 3CB/P6139
    ### third P followed by digit,eg  3JC/P3JC,P  
    ### fourth digit followed by alpha, eg 4C/P5
    splitinto_pattern_MPtop  <-  "[[:digit:]]+[[:alpha:]]+/P[[:digit:]]+|[[:digit:]]+/P[[:digit:]]+|P[[:digit:]]+|[[:digit:]]+$|[[:digit:]]+[[:alpha:]]+$"

    # this will capture something like 00003CAM/00003CAP in which there is number, alpha, M or number, alpha, P
      splitinto_pattern_MPbottom <- "[[:digit:]]+[[:alpha:]]+M|[[:digit:]]+[[:alpha:]]+P|[[:digit:]]+M|[[:digit:]]+P"

        splitinto_pattern_coLTDinc <- "INC|CO|LTD"

  
funcsplit_pattern <- fsis_init_LU_combo
funcsplit_pattern_maxnum = (funcsplit_pattern %>% 
  mutate(
    ncharcombo = nchar(combination) 
  ) %>% 
  filter(
   ncharcombo == max(ncharcombo)
  ))$combination[1]%>% char_unique() %>% nchar()


# fsis_init_LU_combo_patterns <- funcsplit_pattern %>% 
#   summarise(
#     patternfinal = paste(
#       finalpattern %>% unique(), collapse = "|"
#     )
#   ) %>% 
#   ungroup()

# funcfind_pattern <- function(y){
#   
#   
# }


# this takes text and separates this into two columns based on . or , ; eg .PB 
dftext_sep  <- dftext%>%
  mutate(
    textnum = as.numeric(str_squish(text))
  ) %>% 
  filter(
    is.na(textnum) 
  )%>% 
  separate(text, into = c('text1', 'text2'), sep = "\\.|,", fill = "right", remove = FALSE) %>% 
  mutate(
    text2 = gsub(" ", "", text2, perl = TRUE),
    text2_keeporder = text2,
    text2 = stringi_str_order( text2)
  )

# this then filters down to only those where text2 delim column matches those in the pattern (Eg .pb, .s, etc); 
# the last filter step makes sure that the pattern terminates text2
dftext_onlyID1row<- dftext_sep%>% 
  inner_join(
    funcsplit_pattern,# %>% 
      # select(
      #   finalpattern, combination
      # ), 
    by = c("text2" = "combination")
  ) %>% 
  # mutate(
  #   GEOID = purrr::map(files,
  #                      ~readxl::read_excel(.x ))
  # ) %>% 
  filter(
       # rownum == 7643,
   # text2 %in% c(funcsplit_pattern$combination), 
   nchar(text1)>=2 #, 
   # rownum >= 7720
  ) %>% 
  mutate(
    rownum2 = row_number(),
    rownum2_end = paste0("\\", ending, text2_keeporder, "$"),
    text_rmspace =  gsub(" ", "", text)
  ) %>% 
  group_by(
    rownum2
  ) %>% 
  filter(
    grepl(rownum2_end, text_rmspace)
  ) %>% 
  ungroup() %>% 
  filter(
    !grepl(splitinto_pattern_coLTDinc , text, perl = TRUE, ignore.case = TRUE )
  )

dftext_sep_not_prefix <- dftext_sep%>% 
  filter(
    !rownum %in% c(dftext_onlyID1row$rownum )
  )  %>% 
  filter(
    !grepl(splitinto_pattern_coLTDinc , text, perl = TRUE, ignore.case = TRUE )
  )%>% 
  mutate(
    text1_reducespace = gsub("  ", " ", text1, perl = TRUE), 
    text1_nospace = gsub(" ", "", text1, perl = TRUE) 
  )



dftext_sep_not_prefix_bottom <- dftext_sep_not_prefix %>% 
  funcsplit_function_filter_forpattern(x = ., x_filterchar =splitinto_pattern_MPbottom , x_num_tofilter = 3)
# there was a 
dftext_sep_not_prefix %>% 
  filter(
    grepl("04247", text, perl = TRUE)
  ) %>% 
  View()
dftext_sep_not_prefix_bottom %>% 
  filter(
    grepl("04247", text, perl = TRUE)
  ) %>% 
  View()

dftext_onlyID1row_notprefixtop <-   dftext_sep_not_prefix  %>% 
  filter(
    !rownum %in% c(dftext_sep_not_prefix_bottom$rownum )
  )%>% 
  funcsplit_function_filter_forpattern(x = ., x_filterchar =splitinto_pattern_MPtop , x_num_tofilter = 3)

dftext_sep_keeprows <- dftext_onlyID1row %>% 
  bind_rows(
    dftext_sep %>% 
      filter(
    rownum %in% c( 
      dftext_sep_not_prefix_bottom$rownum, 
      dftext_onlyID1row_notprefixtop$rownum
      )
  )
  ) %>% 
  arrange(
    rownum
  )
  

 
  group_by(
    rownum
  ) %>%
  mutate(
    text1_top = 
      paste(
        str_extract_all(
        pattern = splitinto_pattern_MPtop , 
        text1_nospace
      ) %>% unlist(), 
      collapse = "|"
      )
    )%>%
  ungroup() %>% 
  mutate(
    text1_includesPM = 
      paste(
        str_extract_all(
        pattern = splitinto_pattern_MPtop , 
        text1_nospace
      ) %>% unlist(), 
      collapse = "|"
      )
    ) %>%
  ungroup() %>% 
  mutate( 
    text1_countid = 
      case_when(
        (nchar( text1_includesPM) >=2) & 
          (str_count(text1_includesPM , pattern = "\\|") ==0) ~ 1, 
        (nchar( text1_includesPM) >=2) & 
          (str_count(text1_includesPM , pattern = "\\|") >=1)~ 2,
        TRUE ~ 0
      ),
    text1_removePM = 
      case_when(
        nchar( text1_includesPM) >=2 ~ 
          
          str_remove_all(
            string = text1_nospace, 
            pattern = text1_includesPM
          ) 
        
      ), 
    
    numspaces = length(strsplit( text1_reducespace, " ")[[1]]),
    numslash = length(strsplit( text1_reducespace, "/")[[1]]),

    keepthis = 
      case_when(
        # if there is a slash in text1 and matches pattern topid, keep
        (numslash >=1)&
          ( nchar( text1_includesPM) >=2 )&
          (!(nchar(text1_removePM)>=4))~"Y", 
        
        #if there are more than 2 spaces and number of slashes is not > 2, then no ()
        (numspaces >= 2)&(!( numslash >= 2) ) ~ "N", 
        grepl("(MAIL)", text1_reducespace, perl = TRUE, ignore.case = TRUE) ~ "N", 
        # if it's a page number, don't keep it,  just to be safe
         as.numeric( text_reducespace) >= 1 ~ "N",
        # nchar( gsub("[^pPmM]", "", text_reducespace  ))   ~ "Y"  ,
        
        # (grepl( "M[[:digit:]]|[[:digit:]]M|P[[:digit:]]|[[:digit:]]P" ,text_nospace, perl = TRUE, ignore.case = TRUE)) ~  "Y",
       # (lag(text_idno ) == text_idno )| (lead(text_idno) == text_idno) ~ "Y",

        TRUE ~ "N"
      )
    
  )  


# dftext_sep %>%
#   filter(
#     (rownum  ==  12788 )|(rownum == 8478)
#   ) %>%
#   View()


# 
# arch_2000_dec_positions_idsplit <- dftext_onlyID1rowLU %>% 
#   mutate(
#     rownum2 = row_number(), 
#     id = text1,
#     type = text2
#     )# %>% 

# 
# arch_2000_dec_positions_idsplit <- #dftext_onlyID1row %>% 
#   #mutate(
#        cSplit(dftext_onlyID1row, splitCols ="text1", "/", drop = FALSE) %>% 
#   mutate(
#     rownum2 = row_number(), 
#     id = text1,
#     type = text2
#     )# %>% 
 # ) %>% 
  # select(
  #   text:rownum
  # )
 # dftext_onlyID1rowLU <- #dftext_onlyID1row %>% 
 #  #mutate(
 #       cSplit(dftext_sep, splitCols ="text", "/", drop = FALSE) %>% 
 #  gather(
 #    key = textno, 
 #    value = value, 
 #     contains("text_")
 #  ) %>% 
 #  mutate(
 #    textno_num = as.numeric(
 #        gsub(
 #        "[^[:digit:]]", "",  value , perl = TRUE
 #      )
 #      )
 #  ) %>% 
 #  filter(
 #     !is.na(textno_num )
 #  )%>% 
 #  group_by(
 #   text,  rownum
 #  ) %>% 
 #  summarise(
 #    id_no = paste(
 #      textno_num, collapse = "/"
 #    )
 #  ) %>% 
 #  ungroup() 
 # 

 
 # this uses  the function that takes what we belive is the id column; and returns a standardized id format eg M-342/P-234 (ie id_no)

 dftext_onlyID1rowLU <- dftext_onlyID1row%>% 
   # filter()
  funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "text1", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    ) %>% 
   mutate(
     matchtype= "top_id1", 
     id_bait = id_no, 
     id = id_no
   )
   
 # takes the text filters to start; joins to actutal id (id) 
 # and fills down
 # first top id
 # merely taks all text and joins to what I believe is ID
dftext_sep_id1 <- dftext_sep %>% 
  filter(
    rownum >= (dftext_onlyID1row$rownum %>% min())
  ) %>% 
 left_join(
    dftext_onlyID1rowLU %>% 
      rename(
        # id = id_no, 
        type = text2, 
        id_numberonly = id_onlydecimal, 
        id_origtext_id1 = id_origtext, 
        id_numberonly_convertI_1 = id_onlydecimal_convert_I_1
      )  %>% 
      select(rownum, id, id_origtext_id1, type, id_numberonly, id_numberonly_convertI_1)  %>% 
      # mutate(
      #   rownum2 = row_number()
      # )
      distinct(), 
    by = c("rownum")
  ) %>% 
  # mutate(
  #   type = 
  # )
  fill(
    id, .direction = "down"
  )%>% 
    fill(
    id_numberonly, .direction = "down"
  )%>% 

  fill(
     id_numberonly_convertI_1, .direction = "down"
  )%>%
    fill(
     id_origtext_id1, .direction = "down"
  )%>% 

  fill(
     type, .direction = "down"
  )%>% 
  #why is below needed
  mutate(
    firstchar_textcol = substr(text, 1, 1)
    )

### this step produces one column based on the tex
dftext_septext_notid1row <- dftext_sep_id1 %>% 
  # filter(
  #   !rownum %in% c( dftext_onlyID1rowLU$rownum)#,
  #   # rownum >=9218
  # ) %>%
  mutate(
    textoriginal_onlynum = text
  ) %>% 
  select(
  any_of(c(dftext_sep_id1 %>% names(), "textoriginal_onlynum") )  
  ) %>% 
    funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "textoriginal_onlynum", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    )  %>% 
  select(
  rownum, id_onlydecimal , id_onlydecimal_convert_I_1, id_no
  ) %>% 
  distinct() %>% 
      rename(
        # id_bottom = id_no, 
        # id_bottomorigtext = id_origtext ,
        text_onlydecimal = id_onlydecimal  , 
        text_onlydecimal_convert_I_1 = id_onlydecimal_convert_I_1, 
        text_idno = id_no
      )


##  this next step will produce the bottom ids if present
dftext_sep_id1_bottomonly <- dftext_sep_id1 %>% 
  filter(
    !rownum %in% c( dftext_onlyID1rowLU$rownum) 
  ) %>% 
  select(
  any_of(c(dftext_sep_id1 %>% names()) )  
  ) %>% 
    funcsplit_splitinto(
    splintinto_df = ., 
    splitinto_colname = "text1", 
    splintinto_char = "/", 
    splitinto_outputchar = "/"
    ) 

# do this in two parts: ones where 

#labels the bottoms; 
# labels the text
### join
dftext_sep_id1_LU <- dftext_sep_id1 %>% 
  
  left_join(
    dftext_sep_id1_bottomonly %>% 
      rename(
        id_bottom = id_no, 
        id_bottomorigtext = id_origtext ,
        id_bottom_onlydecimal = id_onlydecimal, 
        id_bottom_onlydecimal_convert_I_1 = id_onlydecimal_convert_I_1
      )  %>% 
    
      select(rownum, id_bottom, id_bottomorigtext, id_bottom_onlydecimal, id_bottom_onlydecimal_convert_I_1)  %>% 
      # mutate(
      #   rownum2 = row_number()
      # )
      distinct(), 
    by = c("rownum")
  ) %>% 
  left_join(
    dftext_septext_notid1row, 
    by = c("rownum")
  )

funcsplit_filter_notref <- function( funcsplit_targetdf,funcsplit_targetdf_colorig, funcsplit_targetdf_coltarget,  funcsplit_refdf, matchtypename){
  
  targetdf = funcsplit_targetdf  %>%  
    cbind(
      tibble(
        colorig = funcsplit_targetdf_colorig
      )
    )%>% 
    cbind(
      tibble(
        coltarget = funcsplit_targetdf_coltarget
      )
    )%>% 
    filter(
      !rownum %in% c(funcsplit_refdf$rownum)
    )
 targetdf %>% 

  filter(
    # this allows the standardized id match; or numeric id match in same row
    (colorig == coltarget)
    ) %>% 
  mutate(
    matchtype = matchtypename, 
    id_bait = colorig
  ) %>% 
   select(
     -coltarget, -colorig
   )
}
 
##### 1  exact match

dftext_sep_id1_LU_bottomtop <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref( funcsplit_targetdf = .,funcsplit_targetdf_colorig = .$id_bottom, funcsplit_targetdf_coltarget = .$id,  funcsplit_refdf = dftext_sep_id1_LU %>% head(0) , matchtypename ="bottom_top_exactmatch" )

# dftext_sep_id1_LU_bottomtop <- dftext_sep_id1_LU %>% 
# 
#   filter(
#     # this allows the standardized id match; or numeric id match in same row
#     (id_bottom == id)
#     ) %>% 
#   mutate(
#     matchtype = "bottom_top_exactmatch", 
#     id_bait = id_bottom
#   )
##### 2   exact match
dftext_sep_id1_LU_numberonlytop <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref( funcsplit_targetdf = .,funcsplit_targetdf_colorig = .$id_numberonly, funcsplit_targetdf_coltarget = .$text_onlydecimal,  funcsplit_refdf = dftext_sep_id1_LU_bottomtop, matchtypename ="top_numbermatch" ) 

#### 3 if number of id matches text
dftext_sep_id1_LU_numberonlytop_I_1 <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref( 
    funcsplit_targetdf = .,
    funcsplit_targetdf_colorig = .$id_numberonly ,
    funcsplit_targetdf_coltarget = .$text_onlydecimal_convert_I_1,
    funcsplit_refdf = dftext_sep_id1_LU_numberonlytop,
    matchtypename ="top_numbermatch" ) 
 
dftext_sep_id1_LU_numberonlytop_I_1_number <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref(
    funcsplit_targetdf = .,
    funcsplit_targetdf_colorig = .$id_numberonly_convertI_1  ,
    funcsplit_targetdf_coltarget = .$text_onlydecimal_convert_I_1,
    funcsplit_refdf = dftext_sep_id1_LU_numberonlytop_I_1,
    matchtypename ="top_numbermatch_i_1" 
    ) 


##### 2 number only for top == bottom

dftext_sep_id1_LU_numberonlybottom <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref(
    funcsplit_targetdf = .,
    funcsplit_targetdf_colorig = .$id_numberonly  ,
    funcsplit_targetdf_coltarget = .$id_bottom_onlydecimal,
    funcsplit_refdf = dftext_sep_id1_LU_numberonlytop_I_1_number,
    matchtypename ="bottom_top_numbermatch" 
    ) 

dftext_sep_id1_LU_numberonlybottom_number_i_1 <- dftext_sep_id1_LU %>% 
    funcsplit_filter_notref( 
      funcsplit_targetdf = .,
      funcsplit_targetdf_colorig = .$id_numberonly  ,
      funcsplit_targetdf_coltarget = .$id_bottom_onlydecimal_convert_I_1,
      funcsplit_refdf = dftext_sep_id1_LU_numberonlybottom,
      matchtypename ="bottom_top_numbermatch_number_I_1"
      ) 


dftext_sep_id1_LU_numberonlybottom_i_1 <- dftext_sep_id1_LU %>% 
    funcsplit_filter_notref(
      funcsplit_targetdf = .,
      funcsplit_targetdf_colorig = .$id_numberonly_convertI_1  ,
      funcsplit_targetdf_coltarget = .$id_bottom_onlydecimal_convert_I_1,
      funcsplit_refdf = dftext_sep_id1_LU_numberonlybottom_number_i_1,
      matchtypename ="bottom_top_numbermatch_I_1"
      ) 


# cleanup 
dftext_sep_id1_LU_idmatch <- dftext_sep_id1_LU %>% 
  funcsplit_filter_notref( 
    funcsplit_targetdf = .,
    funcsplit_targetdf_colorig = .$id,
    funcsplit_targetdf_coltarget = .$text_idno,
    funcsplit_refdf =dftext_sep_id1_LU_numberonlybottom_i_1,
    matchtypename ="id_exactmatch" 
    )




dftext_sep_id1_LU_combine <- bind_rows(
  dftext_onlyID1rowLU %>% 
    mutate(
      id_likely = id
    ),
  dftext_sep_id1_LU_bottomtop, 
  dftext_sep_id1_LU_numberonlytop,
  dftext_sep_id1_LU_numberonlytop_I_1,
  dftext_sep_id1_LU_numberonlytop_I_1_number,
  dftext_sep_id1_LU_numberonlybottom,
  dftext_sep_id1_LU_numberonlybottom_number_i_1,
  dftext_sep_id1_LU_numberonlybottom_i_1,
  dftext_sep_id1_LU_idmatch
) %>% 
  group_by(
    rownum
  ) %>% 
  slice(1) %>% 
  ungroup() 

#### 3 last step is to use bottom as bait 

dftext_sep_id1_LU_incombinebait <-dftext_sep_id1_LU %>% 
  filter(
    !rownum %in% c(dftext_sep_id1_LU_combine$rownum )
  )%>% 
  filter(
    # !rownum %in% c(dftext_sep_id1_LU_combine$rownum), 
    rownum <= (
      bind_rows(
        dftext_sep_id1_LU_bottomtop
      )
        

      )$rownum %>% max()
  ) %>% 
  filter(
   ( !is.na(text_idno))|(!is.na(text_onlydecimal ))|(!is.na(text_onlydecimal_convert_I_1 )),
   (text_idno %in% c(dftext_sep_id1_LU_combine$id_bait) )|(text_onlydecimal %in% c(dftext_sep_id1_LU_combine$id_bait) )|(text_onlydecimal_convert_I_1 %in% c(dftext_sep_id1_LU_combine$id_bait) )
  ) %>% 
  mutate(
    text_reducespace = gsub("  ", " ", text), 
    text_nospace = gsub(" ", "", text) , 
    text_includesPM =       
      str_extract(
        pattern = "M[[:digit:]]+|[[:digit:]]+M|P[[:digit:]]+|[[:digit:]]+P",  text_nospace
      ), 
    text_extractPM = 
      case_when(
        nchar( text_includesPM) >=2 ~ 
          
          str_remove_all(
            string = text_nospace, 
            pattern = "M[[:digit:]]+|[[:digit:]]+M|P[[:digit:]]+|[[:digit:]]+P" 
          ) 
        
      ), 
    
    numspaces = length(strsplit( text_reducespace, " ")[[1]]),
    numslash = length(strsplit( text_reducespace, "/")[[1]]),

    keepthis = 
      case_when(
        (lag(text_idno ) == text_idno )| (lead(text_idno) == text_idno) ~ "Y",
                # (grepl( "M[[:digit:]]|[[:digit:]]M|P[[:digit:]]|[[:digit:]]P" ,text_nospace, perl = TRUE, ignore.case = TRUE)) ~  "Y",
        grepl("/", text_reducespace, perl = TRUE,  ) ~"Y", 
        (numspaces >= 2)&(!( numslash >= 2) ) ~ "N", 
        grepl("(MAIL)", text_reducespace, perl = TRUE, ignore.case = TRUE) ~ "N", 
        # if it's a page number
         as.numeric( text_reducespace) >= 1 ~ "N",
        # nchar( gsub("[^pPmM]", "", text_reducespace  ))   ~ "Y"  , 
        (grepl( "M[[:digit:]]|[[:digit:]]M|P[[:digit:]]|[[:digit:]]P" ,text_nospace, perl = TRUE, ignore.case = TRUE)) ~  "Y",
       (lag(text_idno ) == text_idno )| (lead(text_idno) == text_idno) ~ "Y",

        TRUE ~ "Y"
      )
    
  ) %>% 
  select(
    text,text_idno,text_nospace, keepthis, everything()
  ) 

dftext_sep_id1_LU_incombinebait_filter <- dftext_sep_id1_LU_incombinebait %>% 
  filter(
    keepthis == "Y"
  )
  
     bind_rows(
  dftext_sep_id1_LU_numberonlybottom_i_1
  
) %>% 
    funcsplit_filter_notref(
      funcsplit_targetdf = .,
      funcsplit_targetdf_colorig = .$id_bottom_onlydecimal  ,
      funcsplit_targetdf_coltarget = .$text_onlydecimal,
      funcsplit_refdf = dftext_sep_id1_LU_numberonlybottom_i_1,
      matchtypename ="bottom_text_numbermatch"
      ) 


dftext_sep_id2 <- dftext_sep_id1_LU %>% 
  filter(
    # !rownum %in% c(dftext_sep_id1_LU_combine$rownum), 
    rownum <= (
      bind_rows(
        dftext_sep_id1_LU_numberonlybottom # ,
        # dftext_sep_id1_LU_numberonlybottom_number_i_1,
        # dftext_sep_id1_LU_numberonlybottom_i_1
      )
        

      )$rownum %>% max()
  ) %>% 
  left_join(
     dftext_sep_id1_LU_combine %>% 
      select(
        rownum, matchtype, id_bait
      ) %>%
      distinct(),
    by = c("rownum" = "rownum" )
  )
 
  # mutate(
  #   text_idno_guess = text_idno
  # ) %>% 
  # gather(
  #   key = texsplit, 
  #   value = id_bait, 
  #   text_onlydecimal:text_idno
  # ) %>% 
  filter(
   ( !is.na(text_idno))|(!is.na(text_onlydecimal ))|(!is.na(text_onlydecimal_convert_I_1 )),
   (text_idno %in% c(dftext_sep_id1_LU_combine$id_bait) )|(text_onlydecimal %in% c(dftext_sep_id1_LU_combine$id_bait) )|(text_onlydecimal_convert_I_1 %in% c(dftext_sep_id1_LU_combine$id_bait) )
  )  
  # inner_join(
  #   dftext_sep_id1_LU_combine %>% 
  #     select(
  #       rownum, matchtype, id_bait
  #     ) %>% 
  #     distinct(), 
  #   by = c("id_bait" = "id_bait" )
  # )

dftext_sep_id1_LU_withcombineID <- dftext_sep_id1_LU %>% 
  left_join(
    dftext_sep_id1_LU_combine %>% 
      select(
        rownum, matchtype, id_bait
      ) %>% 
      distinct(), 
    by = c("rownum")
  )

# number only for top == bottom
# dftext_sep_id1_LU_otheridonly <- dftext_sep_id1_LU %>% 
#   filter(
#      !rownum %in% c(dftext_sep_id1_LU_bottomtop$rownum),
#     !rownum %in% c(dftext_sep_id1_LU_numberonly$rownum),
#      !rownum %in% c(dftext_sep_id1_LU_numberonly_I_1$rownum),
#    
#   (text_onlydecimal ==id_bottom_onlydecimal )|(text_onlydecimal == id_bottom_onlydecimal_convert_I_1 )
#   )

 arch_2000_dec_text_begin_id <- dftext_sep_id1 %>% 
   left_join(
     dftext_sep_id1_LU %>% 
       select(
        rownum, id_bottom, id_bottomorigtext, id_bottom_onlydecimal, id_bottom_onlydecimal_convert_I_1,text_onlydecimal
       ) %>% 
       distinct(),
     by= c("rownum")
   ) %>% 
   group_by(
     id
   ) %>% 
  #   fill(
  #    id_bottomorigtext, .direction = "down"
  # )%>% 
    fill(
     id_bottom, .direction = "up"
  )%>% 
    fill(
     id_bottomorigtext, .direction = "up"
  ) %>% 
  fill(
     id_bottom_onlydecimal, .direction = "up"
  )%>% 
  fill(
     id_bottom_onlydecimal_convert_I_1, .direction = "up"
  )%>% 

   ungroup()
 # ones that don't have accompanying bottom
 # 7238 rownum 
# 12PA/P834 row7298 (both 7298 and 7238 should include an M in first P if there are two Ps)
 # 7465 # BM-21/P-748 21B/P748,PY; end is 0002 IB  M/00748  P (bc i gets coded as 1)
 # at end of day, just want 
 
 ### 7/23;
 # # problem with row 7720	
# 850/P17775.SPBEIY 
 
 ## problem with 9218; doesn't have .PB, so doesn't get labelled as ID first go around. Solve by simply making 
 arch_2000_dec_text_begin_id %>% 
   filter(
     is.na(( id_bottomorigtext))
   ) %>% 
   View()
# 
#    dftext_sep_id1%>% 
#     filter(
#         id == "00226  M/04863"
#     ) %>% View()

 # this begins to take 
arch_2000_dec_text_begin_firmLU <- arch_2000_dec_text_begin_id %>% 
  filter(
    firstchar_textcol != "("
  ) %>% 
  group_by(
    id
  ) %>% 
  # mutate(
  #   notes = p
  # )
  mutate(
    id_rownum = row_number()
  ) %>% 
  ungroup() %>% 
  mutate(
    firstchar_textcol2= substr(text, 1, 1),
    firm  = case_when(
      (
        (id_rownum ==2) #
        & firstcharfirm != "("
        )~ gsub(
         "&amp;", "", 
          text  
        )
    ), 
    rownum_firmLU = 
      case_when(
        !is.na(firm) ~ rownum
      )
) %>% 
  group_by(
    id, rownum2
  )  %>% 
  fill(
    firm,  .direction = "downup"
  )%>% 
  fill(
    rownum_firmLU,  .direction = "downup"
  ) %>% 
  ungroup() %>% 
  select(
    id, rownum2, firm, rownum_firmLU
    ) %>% 
  distinct() %>% 
  #needed to fill in NA in case 
  fill(
    firm, .direction = "down"
  )%>% 
  fill(
    rownum_firmLU,  .direction = "down"
  ) 

arch_2000_dec_text_begin_firm <- dftext_sep_id1 %>% 
  left_join(
    arch_2000_dec_text_begin_firmLU, 
    by = c("id", "rownum2")
  ) 

arch_2000_dec_text_begin_otherprocess <- arch_2000_dec_text_begin_firm %>% 
  filter(
    firstcharfirm  == "(" 
  ) %>% 
  mutate(
    ifmail = substr(text, 1,6) 
  ) %>% 
  filter(
    !grepl( "(MAIL)" , ifmail, ignore.case = TRUE, perl = TRUE), 
    grepl("INSPECTION",text , ignore.case = TRUE, perl = TRUE)
  ) %>% 
  mutate(
    type_specialinspect = (gsub(
       "[^[:alpha:]]|INSPECTION", "", str_squish(text)
      )
  )
  )%>% 
  group_by(
    id, rownum2
  ) %>% 
  summarise(
    type_specialinspect =  paste(type_specialinspect %>% unique() %>% sort(), collapse = ", ")
  ) %>% 
  ungroup()
#%>% 
  # mutate(
  #   firm = case_when(
  #     (is.na(firm) & (id_rownum ==3) & firstcharfirm != "(" )~ text,
  #     TRUE ~ firm
  #   ),
  #     
  #     firm = gsub(
  #       "  ", " ", 
  #       gsub(
  #      "&amp;", "&",  firm
  #     )
  #     
  #     )
  #    
  #   
  # )%>% 
  # group_by(
  #   id, rownum2
  # )  %>% 
  # fill(
  #   firm,  .direction = "downup"
  # )%>% 
  # ungroup()

arch_2000_dec_text_begin_stateLU <-  arch_2000_dec_text_begin_firm %>% 
  filter(
    nchar( text2) >=2
  ) %>% 
  mutate(
    poss_state = 
      gsub(
       "[^[:alpha:]]", "", str_squish(text2)
      )
      # sub(".*\\b([A-Z]{2}).*", "\\1", str_squish(text2))
  ) %>% 
  filter(
    poss_state %in% c(fips_codes$state)
  ) %>% 
  group_by(
    id, rownum2, firm
  ) %>% 
  mutate(
    rownum_state = row_number() 
  ) %>% 
  ungroup() %>%  
  filter(
    (rownum_state == 1 )| ( rownum_state == 2 & rownum2 == max(rownum2))
  )

arch_2000_dec_text_begin_state <- arch_2000_dec_text_begin_firm %>% 
  filter(
    rownum < (arch_2000_dec_text_begin_stateLU$rownum %>% max()) 
  ) %>% 
  left_join(
    arch_2000_dec_text_begin_stateLU %>% 
      filter(rownum_state == 1  ) %>%
      mutate(rownum_stateLU  = rownum) %>% 
      select(poss_state, rownum2, id, rownum_stateLU), 
    by = c("rownum2", "id")
  ) %>% 
  left_join(
     arch_2000_dec_text_begin_otherprocess %>% 
      # mutate(
      #   rownum_otherprocessLU  = rownum
      #   ) %>% 
      select(type_specialinspect , rownum2, id), 
    by = c("rownum2", "id")
  )
arch_2000_dec_text_begin_addressLU <- arch_2000_dec_text_begin_state  %>% 
  filter(
    rownum ==  (rownum_stateLU -1)
    # (rownum <=  (rownum_stateLU-1)) & (rownum >rownum_firmLU) 
  )
   
arch_2000_dec_text_begin_address <- arch_2000_dec_text_begin_state %>% 
  left_join(
    arch_2000_dec_text_begin_addressLU %>% 
      mutate(
        street = text
      ) %>% 
      select(
        street, rownum2, id
      ), 
    by = c("rownum2", "id")
  ) %>% 
  rename(
  state   = poss_state 
  ) %>% 
  group_by(
    rownum2, id
  ) %>% 
  mutate(
    rownum2_rownumwithin = row_number()
  ) %>% 
  ungroup()

arch_2000_dec_text_begin_idLU <-
  # split these into all ids, then gather
         cSplit(arch_2000_dec_text_begin_address, splitCols ="text1", "/", drop = FALSE) %>% 
  select(
    text1,id, rownum2, contains("text1_")
  ) %>% 
  cbind(
    cSplit(arch_2000_dec_text_begin_address, splitCols ="id", "/", drop = FALSE) %>% 
  select(
    contains("id_")
  )
  ) %>% 
  gather(
    key = textno, 
    value = value, 
     contains("text1_"), contains("id_")
  )  

  arch_2000_dec_text_begin_idLU2 <-  arch_2000_dec_text_begin_idLU %>% 
    mutate(
      id_letter =  gsub(
       "[^[:alpha:]]", "",  value 
      ),
      id_number = as.numeric(
        gsub(
        "[^[:digit:]]", "",  value 
      )
      )
    ) %>% 
    filter(
    nchar(id_number) >=1
    ) 
  
arch_2000_dec_text_begin_idLU3 <-arch_2000_dec_text_begin_idLU2  %>% 
    mutate(
      id_letter_M =
        case_when(
         (  text1== id) & !(nchar(id_letter)>=1) ~ "M",
         ((  text1== id)&  grepl("text1_", textno, perl = TRUE))  ~ paste0( id_letter,"M"),
         (!(nchar(id_letter)>=1) &  grepl("id_", textno, perl = TRUE)) ~ "M",

          TRUE ~ id_letter
        ) ,
      id_concat_m = paste0(id_letter_M,id_number )
    ) %>% 
  distinct() %>% 
  group_by(
    id,textno, id_concat_m, rownum2
  ) %>% 
  mutate(
    num_id_m_occur = n(), 
    num_id_m_occur_rowid = row_number()
  ) %>% 
  ungroup()
arch_2000_dec_text_begin_idLU3 %>% 
  filter(
    id == "00226  M/04863"
  ) %>% View()

"00226  M/04863"
# this should pull all top ids and trailing ids 
arch_2000_dec_text_begin_idLU4 <-arch_2000_dec_text_begin_idLU3%>% 
  filter(
     grepl("text1_", textno, perl = TRUE), 
     # ==2 should be trailing OR id = text1 captures top id
    ( num_id_m_occur ==2 )| ( id == text1) 
  ) %>% 
  group_by(
    id
  ) %>% 
  summarise(
    id_concat_m = paste( id_concat_m %>% unique() %>% sort(), collapse = "+")
  ) %>% 
  ungroup()
  
  left_join(
    arch_2000_dec_text_begin_idLU3%>% 
  filter(
     grepl("id_", textno, perl = TRUE)
  )
  )
  
#needs to be a bind !id in above

arch_2000_dec_text_begin_idLU3 %>% 
  filter(
    grepl("text1", textno, perl = TRUE)
  )   %>% 
  group_by(
    num_id_m_occur
  ) %>% 
  summarise(
    count = length(unique(id))
  ) %>% 
  arrange(-count) %>% 
  View()
    
arch_2000_dec_text_begin_idLU4 <- arch_2000_dec_text_begin_idLU3%>% 
  select(
 id,textno, id_concat_m, rownum2
  ) %>% 
  distinct() %>% 
  mutate(
    idtype = gsub("_.*","", textno, perl = TRUE )
  ) %>% 
  group_by(
    id,id_concat_m, rownum2
  )

  mutate(
    id_possible_number = 
      # paste(
      stringr::str_extract_all(value, "M|P|\\d+"), 
        id_top_possible_number = 
      # paste(
      stringr::str_extract_all(id, "M|P|\\d+")#, 

    # if_backslash = 
    #   gsub(
    #     "[^\\/]", "", text1
    #   )
      #   collapse = "/"
      # )#,
      
      # gsub("([0-9]+).*$", "\\1", text) 
  ) %>% 
  # filter(
  #   id_possible_number != "character(0)"
  # ) %>%
  unnest(
    cols = c("id_possible_number")
  ) %>%
  unnest(
    cols = c("id_top_possible_number")
  ) %>% 
 group_by(rownum, firm, text,rownum2) %>% 
  summarise(
    id_possible_number = paste(id_possible_number %>% unique() %>%as.numeric() %>%  sort() , collapse = "/" ),
    id_top_possible_number = paste(id_top_possible_number %>% unique() %>%as.numeric() %>%  sort() , collapse = "/" )
  ) %>% 
  ungroup() %>%  
  filter(
    id_possible_number ==id_top_possible_number
  )
 transmute(
   id_possible_number  = str_c(c_across("id_possible_number"), collapse = "/"),
   id_top_possible_number = str_c(c_across("id_top_possible_number"), collapse = "/") 
   
   
   )
  group_by(
    rownum2, id
  ) %>% 
  filter(
    rownum2_rownumwithin == max( rownum2_rownumwithin)
  ) %>% 
  ungroup()
arch_2000_dec_text_begin_dbaLU <- arch_2000_dec_text_begin_address %>% 
  filter(
    rownum < (arch_2000_dec_text_begin_stateLU$rownum %>% max()) 
  ) %>% 
  left_join(
    
  )

  summarise(
    
  )
  # fill()
  mutate(
    rownum2 = fill( )
  )
    

}
 
  
```

# git code 
```{r }
# https://rogerdudler.github.io/git-guide/
# https://rfortherestofus.com/2021/02/how-to-use-git-github-with-r/
# git add *
# git commit -m "committed 230723"
# git push origin 

```



## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
